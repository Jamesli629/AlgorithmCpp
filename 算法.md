# 算法

## BFS

1. 应用场景
   - 最短用时
   - 无权的最短路径
   - 搜索
   
2. 模板

   ``` c++
   bool vst[maxn][maxn]; // 访问标记
   int dir[4][2]={0,1,0,-1,1,0,-1,0}; // 方向向量
   
   struct State // BFS 队列中的状态数据结构
   {
   int x,y; // 坐标位置
   int Step_Counter; // 搜索步数统计器
   };
   bool CheckState(State s) // 约束条件检验
   {
   if(!vst[s.x][s.y] && ...) // 满足条件
   return 1;
   else // 约束条件冲突
   return 0;
   }
   void bfs(State st)
   {
           queue<State> q;      // BFS 队列
           State now, next;     // 定义2 个状态，当前和下一个
           st.Step_Counter = 0; // 计数器清零
           q.push(st);          // 入队
           vst[st.x][st.y] = 1; // 访问标记
           while (!q.empty())
           {
                   now = q.front(); // 取队首元素进行扩展
               	q.pop(); // 队首元素出队
                   if (now == G)    // 出现目标态，此时为Step_Counter 的最小值，可以退出即可
                   {
                           ...... // 做相关处理
                               return;
                   }
                   for (int i = 0; i < 4; i++)
                   {
                           next.x = now.x + dir[i][0]; // 按照规则生成下一个状态
                           next.y = now.y + dir[i][1];
                           next.Step_Counter = now.Step_Counter + 1; // 计数器加1
                           if (CheckState(next))                     // 如果状态满足约束条件则入队
                           {
                                   q.push(next);
                                   vst[next.x][next.y] = 1; //访问标记
                           }
                   }
   
           }
           return;
   }
   
   int main()
   {
           ...... return 0;
   }
   
   
   ```

   ## 算法竞赛代码习惯
   
   ```c++
   //最好不要用宏定义，改用const
   const int MAX=1000005;
   
   //如果需要用到很大的存储空间，尽量直接定义全局静态数组
   //需要动态空间，用STL中的vector
   
   //以下两句话，可以将cin和cout的效率提升至和scanf和printf差不多
   ios::sync_with_stdio(false);
   cin.tie(0);
   //这样写了之后要注意不要再混用cin，cout和scanf，printf了。
   
   //递归（重要基础）
   //求全排列 用递归（是标准的解法）
   int star[]={0,1,2,3,4,5,6,8,9,10,12};  //0不用
   #define Swap(a,b){int temp=a;a=b;b=temp;}//交换
   int num=0;//统计全排列的个数
   int Perm(int begin,int end){
       int i;
       if(begin==end)//结束，输出一个全排列
           num++;//统计全排列的个数
       else
           for(i=begin;i<=end;i++){
               Swap(star[begin],star[i]);//交换位置，逐步前提
               Perm(begin+1,end);
               Swap(star[begin],star[i]);//将位置还回去，对下一次排列负责
           }
   }
   
   //涉及到迭代器的时候，可用auto来定义变量类型，但后面一定要初始化
   
   ```
   
   ```c++
   //看到是有序的数组时，基本最先想到的就是使用二分去查找
   ```
   
   